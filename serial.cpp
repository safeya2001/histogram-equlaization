#include <iostream>#include <opencv2/opencv.hpp>using namespace std;using namespace cv;#define ROWS 186#define COLS 182void make_histogram(double R[][COLS], double G[][COLS], double B[][COLS], int histogram[], int yuv_vector[]){    // initialize all intensity values to 0    for (int i = 0; i < 256; i++)    {        histogram[i] = 0;    }    for (int i = 0; i < ROWS; i++)    {        for (int j = 0; j < COLS; j++)        {            int Y = (int)(R[i][j] * .299000 + G[i][j] * .587000 + B[i][j] * .114000);            int U = (int)(R[i][j] * -.168736 + G[i][j] * -.331264 + B[i][j] * .500000 + 128);            int V = (int)(R[i][j] * .500000 + G[i][j] * -.418688 + B[i][j] * -.081312 + 128);            histogram[Y]++;            int index = (i * COLS + j) * 3;            yuv_vector[index] = Y;            yuv_vector[index + 1] = U;            yuv_vector[index + 2] = V;        }    }}void cumulative_histogram(int histogram[], int equalized[]){    int cumulative_histogram[256];    cumulative_histogram[0] = histogram[0];    for (int i = 1; i < 256; i++)    {        cumulative_histogram[i] = histogram[i] + cumulative_histogram[i - 1];        equalized[i] = (int)(((float)cumulative_histogram[i] - histogram[0]) / ((float)COLS * ROWS - 1) * 255);    }}void equalize(double R[][COLS], double G[][COLS], double B[][COLS], int equalized[], int yuv_vector[]){    for (int i = 0; i < ROWS; i++)    {        for (int j = 0; j < COLS; j++)        {            int index = (i * COLS + j) * 3;            int Y = equalized[yuv_vector[index]];            int U = yuv_vector[index + 1];            int V = yuv_vector[index + 2];            R[i][j] = (double)max(0, min(255, (int)(Y + 1.4075 * (V - 128))));            G[i][j] = (double)max(0, min(255, (int)(Y - 0.3455 * (U - 128) - (0.7169 * (V - 128)))));            B[i][j] = (double)max(0, min(255, (int)(Y + 1.7790 * (U - 128))));        }    }}int main(){    // Load the image    Mat image = imread("/home/safsaf/Downloads/im", cv::IMREAD_COLOR);    if (image.empty())    {        cout << "Error: Could not open or find the image" << endl;        return -1;    }    // Extract R, G, B channels from the image    double R[ROWS][COLS];    double G[ROWS][COLS];    double B[ROWS][COLS];    for (int i = 0; i < ROWS; ++i)    {        for (int j = 0; j < COLS; ++j)        {            Vec3b intensity = image.at<Vec3b>(i, j);            R[i][j] = intensity.val[2]; // Red channel            G[i][j] = intensity.val[1]; // Green channel            B[i][j] = intensity.val[0]; // Blue channel        }    }    // Generate the histogram    int histogram[256] = {0}; // Initialize to 0    int *yuv_vector = new int[ROWS * COLS * 3];    make_histogram(R, G, B, histogram, yuv_vector);    // Generate the equalized histogram    int equalized[256] = {0}; // Initialize to 0    cumulative_histogram(histogram, equalized);    // Apply histogram equalization to R, G, B channels    equalize(R, G, B, equalized, yuv_vector);    // Create Mat object for the final image    Mat final_image(ROWS, COLS, CV_8UC3);    // Fill the final image with equalized R, G, B channels    for (int i = 0; i < ROWS; ++i)    {        for (int j = 0; j < COLS; ++j)        {            Vec3b& intensity = final_image.at<Vec3b>(i, j);            intensity[2] = saturate_cast<uchar>(R[i][j]); // Red channel            intensity[1] = saturate_cast<uchar>(G[i][j]); // Green channel            intensity[0] = saturate_cast<uchar>(B[i][j]); // Blue channel        }    }    // Display the final image    imshow("Final Image", final_image);    imwrite("/home/safsaf/Downloads/final_image.jpg", final_image);    waitKey(0);    // Clean up memory    delete[] yuv_vector;    return 0;}