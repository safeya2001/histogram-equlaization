#include <iostream>#include <opencv2/opencv.hpp>#include <fstream>#include <string>#include <algorithm>#include <omp.h>using namespace std;using namespace cv;#define ROWS 189#define COLS 267double R[ROWS][COLS];double G[ROWS][COLS];double B[ROWS][COLS];void readImage(const string& filename){    Mat image = imread(filename, cv::IMREAD_COLOR);    if (image.empty())    {        cout << "Error: Could not open or find the image" << endl;        exit(EXIT_FAILURE);    }    for (int i = 0; i < ROWS; ++i)    {        for (int j = 0; j < COLS; ++j)        {            Vec3b intensity = image.at<Vec3b>(i, j);            R[i][j] = intensity.val[2]; // Red channel            G[i][j] = intensity.val[1]; // Green channel            B[i][j] = intensity.val[0]; // Blue channel        }    }}void make_histogram(double R[][COLS], double G[][COLS], double B[][COLS], int histogram[], int yuv_vector[]){    // initialize all intensity values to 0    for (int i = 0; i < 256; i++)    {        histogram[i] = 0;    }    #pragma omp parallel for collapse(2)    for (int i = 0; i < ROWS; i++)    {        for (int j = 0; j < COLS; j++)        {            int Y = (int)(R[i][j] * .299000 + G[i][j] * .587000 + B[i][j] * .114000);            int U = (int)(R[i][j] * -.168736 + G[i][j] * -.331264 + B[i][j] * .500000 + 128);            int V = (int)(R[i][j] * .500000 + G[i][j] * -.418688 + B[i][j] * -.081312 + 128);            #pragma omp critical            histogram[Y]++;            int index = (i * COLS + j) * 3;            yuv_vector[index] = Y;            yuv_vector[index + 1] = U;            yuv_vector[index + 2] = V;        }    }}void cumulative_histogram(int histogram[], int equalized[]){    int cumulative_histogram[256];    cumulative_histogram[0] = histogram[0];    for (int i = 1; i < 256; i++)    {        cumulative_histogram[i] = histogram[i] + cumulative_histogram[i - 1];    }    #pragma omp parallel for    for (int i = 0; i < 256; i++)    {        equalized[i] = (int)(((float)cumulative_histogram[i] - histogram[0]) / ((float)COLS * ROWS - 1) * 255);        equalized[i] = max(0, min(255, equalized[i]));    }}void equalize_image(double R[][COLS], double G[][COLS], double B[][COLS], int equalized[], int yuv_vector[]){    #pragma omp parallel for collapse(2)    for (int i = 0; i < ROWS; i++)    {        for (int j = 0; j < COLS; j++)        {            int index = (i * COLS + j) * 3;            int Y = equalized[yuv_vector[index]];            int U = yuv_vector[index + 1];            int V = yuv_vector[index + 2];            R[i][j] = (double)max(0, min(255, (int)(Y + 1.4075 * (V - 128))));            G[i][j] = (double)max(0, min(255, (int)(Y - 0.3455 * (U - 128) - (0.7169 * (V - 128)))));            B[i][j] = (double)max(0, min(255, (int)(Y + 1.7790 * (U - 128))));        }    }}int main(){    readImage("/home/safsaf/Downloads/ima");    int histogram[256] = {0};    int *yuv_vector = new int[ROWS * COLS * 3];    make_histogram(R, G, B, histogram, yuv_vector);    int equalized[256] = {0};    cumulative_histogram(histogram, equalized);    equalize_image(R, G, B, equalized, yuv_vector);    Mat final_image(ROWS, COLS, CV_8UC3);    #pragma omp parallel for    for (int i = 0; i < ROWS; ++i)    {        for (int j = 0; j < COLS; ++j)        {            Vec3b& intensity = final_image.at<Vec3b>(i, j);            intensity[2] = saturate_cast<uchar>(R[i][j]);            intensity[1] = saturate_cast<uchar>(G[i][j]);            intensity[0] = saturate_cast<uchar>(B[i][j]);        }    }    imshow("Final Image", final_image);    imwrite("/home/safsaf/Downloads/final_image.jpg", final_image);    waitKey(0);    delete[] yuv_vector;    return 0;}