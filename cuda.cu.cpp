#include <iostream>#include <stdio.h>#include <stdlib.h>#include <math.h>#include <time.h>#include <cuda_runtime.h>using namespace std;#define ROWS 182#define COLS 186global void make_histogram(double* R[], double* G[], double* B[], int* histogram, int* yuv_vector){    int i = blockDim.x * blockIdx.x + threadIdx.x;    int j = blockDim.y * blockIdx.y + threadIdx.y;    if (i >= 0 && i < ROWS && j >= 0 && j < COLS) {        int Y = R[i][j] * .299000 + G[i][j] * .587000 + B[i][j] * .114000;        int U = R[i][j] * -.168736 + G[i][j] * -.331264 + B[i][j] * .500000 + 128;        int V = R[i][j] * .500000 + G[i][j] * -.418688 + B[i][j] * -.081312 + 128;        atomicAdd(&(histogram[Y]), 1);        int index = (j * ROWS + i) * 3;        yuv_vector[index] = Y;        yuv_vector[index + 1] = U;        yuv_vector[index + 2] = V;    }    __syncthreads();}global void cumulative_hist(int* histogram, int* equalized, int* cumulative_histogram){    int i = blockDim.x * blockIdx.x + threadIdx.x;    equalized[i] = (int)(((float)cumulative_histogram[i] - histogram[0]) / ((float)COLS * ROWS - 1) * 255);}global void cal_equalize(double* R[], double* G[], double* B[], int* equalized, int* yuv_vector){    int i = blockDim.x * blockIdx.x + threadIdx.x;    int j = blockDim.y * blockIdx.y + threadIdx.y;    if (i >= 0 && i < ROWS && j >= 0 && j < COLS) {        int index = (j * ROWS + i) * 3;        int Y = equalized[yuv_vector[index]];        int U = yuv_vector[index + 1];        int V = yuv_vector[index + 2];        R[i][j] = (double)max(0, min(255, (int)(Y + 1.4075 * (V - 128))));G[i][j] = (double)max(0, min(255, (int)(Y - 0.3455 * (U - 128) - (0.7169 * (V - 128)))));B[i][j] = (double)max(0, min(255, (int)(Y + 1.7790 * (U - 128))));    }}int main(){    int i, j;    double **R, **G, **B;    double cpu_time;    clock_t begin, end;    cudaMallocManaged(&R, ROWS * sizeof(double*));    cudaMallocManaged(&G, ROWS * sizeof(double*));    cudaMallocManaged(&B, ROWS * sizeof(double*));    for (i = 0; i < ROWS; i++) {        cudaMallocManaged(&R[i], COLS * sizeof(double));        cudaMallocManaged(&G[i], COLS * sizeof(double));        cudaMallocManaged(&B[i], COLS * sizeof(double));    }    int blockx = ROWS / 32 + 1;    int blocky = COLS / 32 + 1;    dim3 grid_dims, block_dims;    grid_dims.x = blockx; // number of blocks in the x-dimension    grid_dims.y = blocky; // number of blocks in the y-dimension    block_dims.x = 32;    // number of threads in the x-dimension    block_dims.y = 32;    // number of threads in the y-dimension    begin = clock();    int *yuv_vector, *histogram, *equalized, *cumulative_histogram;    cudaMallocManaged(&yuv_vector, ROWS * COLS * 3 * sizeof(int));    cudaMallocManaged(&histogram, 256 * sizeof(int));    cudaMallocManaged(&equalized, 256 * sizeof(int));    cudaMallocManaged(&cumulative_histogram, 256 * sizeof(int));    // initialize all intensity values to 0    for (int i = 0; i < 256; i++) {        histogram[i] = 0;    }    make_histogram <<<grid_dims, block_dims>>> (R, G, B, histogram, yuv_vector);    cudaDeviceSynchronize();    cumulative_histogram[0] = histogram[0];    for (int i = 1; i < 256; i++)        cumulative_histogram[i] = histogram[i] + cumulative_histogram[i - 1];    cumulative_hist <<<1, 256>>> (histogram, equalized, cumulative_histogram);    cudaDeviceSynchronize();    cal_equalize <<<grid_dims, block_dims>>> (R, G, B, equalized, yuv_vector);    cudaDeviceSynchronize();    end = clock();    cpu_time = (double)(end - begin) / CLOCKS_PER_SEC;    cout << cpu_time << endl;    return 0;}